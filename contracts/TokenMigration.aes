payable contract TokenMigration =

    datatype event = Migrated(bytes(20), address, int)

    type set('a) = map('a, unit)

    record state =
        { root_hash: string,
          migrations_count: int,
          map_transfered_accounts: set(string) }

    entrypoint init(root_hash: string, count: int) : state =
        { root_hash = root_hash,
          migrations_count = count,
          map_transfered_accounts = {} }

    // 'eth_addr_str' should be passed as uppercase
    payable stateful entrypoint migrate(amount_of_tokens: int, ae_address: address, leaf_index: int, siblings: list(string), eth_addr_str: string, eth_address: bytes(20), sig: bytes(65), msg_hash: hash) =

        require(!Map.member(eth_addr_str, state.map_transfered_accounts), "This account has already transferred its tokens")
        require(Address.is_payable(ae_address), "Passed AE address is not payable")

        // should successfully generate same merkle tree root hash
        let is_contained = contained_in_merkle_tree(eth_addr_str, amount_of_tokens, leaf_index, siblings)
        require(is_contained, "From provided data, cannot be generated same root")

        // extract signer of signature, should be same address that holds tokens
        let recovered_address = get_signer(msg_hash, sig)
        let are_equal = switch (recovered_address)
                            None => false
                            Some(recovered) => recovered == eth_address

        require(are_equal, "Mismatch between passed eth address and recovered one")

        Chain.spend(ae_address, amount_of_tokens)
        put(state{migrations_count = state.migrations_count + 1})
        put(state{map_transfered_accounts[eth_addr_str] = ()})

        Chain.event(Migrated(eth_address, ae_address, amount_of_tokens))

        state.migrations_count

    function get_signer(msg_hash: hash, sig: bytes(65)) =
        Crypto.ecrecover_secp256k1(msg_hash, sig)

    entrypoint contained_in_merkle_tree(eth_addr: string, tokens: int, leaf_index: int, siblings: list(string) ) =
        // concat data => eth_Addr:tokens => concatenated data
        let data = String.concat(eth_addr, ":")
        let data = String.concat(data, Int.to_str(tokens))

        // concatenated data -> hash
        let data = Bytes.to_str(String.sha3(data)) // hash -> str

        //let data = Bytes.to_str(String.sha3(String.concat(eth_addr, ":", tokens))) // not working ?!

        let root = calculate_root(siblings, leaf_index, data)

        // genarated merkle tree hash should be same as inited one
        root == state.root_hash

    function calculate_root(els : list(string), index : int, root : string) =
        switch(els)
            []        => root
            el :: els =>
                let data = if (index mod 2 == 1) String.concat(el, root) else String.concat(root, el)
                calculate_root(els, index / 2, Bytes.to_str(String.sha3(data)))

    // Test only?
    stateful entrypoint update_root(new_root: string) =
        only_owner()
        put(state{root_hash = new_root})

    entrypoint balance() = Contract.balance
    entrypoint root_hash() = state.root_hash
    entrypoint migrations_count() = state.migrations_count
    entrypoint is_migrated(eth_address: string) = Map.member(eth_address, state.map_transfered_accounts)

    function only_owner() =
        require(Call.caller == Contract.creator, "Owner require")
